install.packages("RMySQL")
library(datasets)
data(iris)
?iris
?mean
mean(iris$sepal.length, 'virginica')
mean(iris$sepal.length, iris$sepal.length='virginica')
?split
split(iris, iris$sepal.length)
head(iris)
split(iris, iris$species)
split(iris, iris$Species)
split(iris, iris$Species)$virginica
split(iris, iris$Species)$virginica$Sepal.Length
mean(split(iris, iris$Species)$virginica$Sepal.Length)
?iris
type <- 'virginica'
mean(split(iris, iris$Species)[type]$Sepal.Length)
type <- 'virginica'
mean(split(iris, iris$Species)[[type]]$Sepal.Length)
rowMeans(iris[, 1:4])
apply(iris[, 1:4], 1, mean)
colMeans(iris)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
apply(mtcars, 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
View(mtcars)
split(mtcars, mtcars$cyl)
?average
?colmeans
mean(split(mtcars, mtcars$cyl))$4$cyl
mean(split(mtcars, mtcars$cyl)$4$cyl)
mean(split(mtcars, mtcars$cyl)$4$cyl)
mean(split(mtcars, mtcars$cyl)$'4'$cyl)
split(mtcars, mtcars$cyl)$'4'
split(mtcars, mtcars$cyl)$'4'$cyl
mean(split(mtcars, mtcars$cyl)$'4'$hp)
mean(split(mtcars, mtcars$cyl)$'8'$hp)
8cyl_meanHP-4cyl_meanHP
8cyl_meanHP - 4cyl_meanHP
5-2
'8cyl_meanHP' - '4cyl_meanHP'
4cyl_meanHP <- mean(split(mtcars, mtcars$cyl)$'4'$hp)
8cyl_meanHP <- mean(split(mtcars, mtcars$cyl)$'8'$hp)
8cyl_meanHP - 4cyl_meanHP
4cyl_meanHP <- mean(split(mtcars, mtcars$cyl)$'4'$hp)
4cylMeanHP <- mean(split(mtcars, mtcars$cyl)$'4'$hp)
mean(split(mtcars, mtcars$cyl)$'8'$hp) - mean(split(mtcars, mtcars$cyl)$'4'$hp)
4cylMeanHP = mean(split(mtcars, mtcars$cyl)$'4'$hp)
4cylMeanHP <- 5
4cylMnHP <- 5
MnHP_4cyl
x <- 5
x <- mean(split(mtcars, mtcars$cyl)$'4'$hp)
y <- mean(split(mtcars, mtcars$cyl)$'8'$hp)
y-x
debug(ls)
ls
?ls
m
q
setwd("~/")
setwd("C:/Documents and Settings/admin/GIT/ProgrammingAssignment2")
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getmean <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting inversed data")
return(i)
}
data <- x$get()
i <- inverse(data, ...)
x$setinverse(i)
i
}
my_matrix <- rbind(c(2,5),c(7,8))
my_matrix
cacheSolve(my_matrix)
makeCacheMatrix(my_matrix)
## Coursera course: R programming (https://class.coursera.org/rprog-008)
## Programming assignment 2 - Caching the inverse of a matrix (week 3)
## Author: Peter Van Hoof
## makeCacheMatrix:
##      This function creates a special "matrix" object that
##      can cache its inverse. It is a list containing a function to
##      1. set the value of the matrix
##      2. get the value of the matrix
##      3. set the value of the inverse matrix
##      4. get the value of the inverse matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve:
##      This function computes the inverse of the special "matrix" returned
##      by makeCacheMatrix above. If the inverse has already been calculated
##      (and the matrix has not changed), then the cachesolve should retrieve
##      the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
my_matrix <- rbind(c(2,5),c(7,8))
makeCacheMatrix(my_matrix)
cacheSolve(my_matrix)
n <- makeCacheMatrix(my_matrix)
n
n$set
## overall description
## below 2 functions that
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getmean <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting inversed data")
return(i)
}
data <- x$get()
i <- inverse(data, ...)
x$setinverse(i)
i
}
## the lines below test the function and can be disregarded
my_matrix <- rbind(c(2,5),c(7,8))
cacheSolve(my_matrix)
makeCacheMatrix(my_matrix)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting inversed data")
return(i)
}
data <- x$get()
i <- inverse(data, ...)
x$setinverse(i)
i
}
## the lines below test the function and can be disregarded
my_matrix <- rbind(c(2,5),c(7,8))
makeCacheMatrix(my_matrix)
makeCacheMatrix$set(my_matrix)
makeCacheMatrix$get(my_matrix)
cacheSolve(my_matrix)
cacheSolve$get(my_matrix)
my_object <- makeCacheMatrix(my_matrix)
my_object$get)
my_object$get
my_object$get(my_matrix)
my_object$getinverse(my_matrix)
inverse(my_matrix)
?inverse
??inverse
